from typing import List, Dict
import re
import os
import json
from tqdm import tqdm
from together import Together

TOGETHER_API_KEY = os.getenv("TOGETHER_API_KEY")
assert TOGETHER_API_KEY, "Together API key is requierd to generate data"

# -- Together API client. Automatically uses the TOGETHER_API_KEY environment variable -- #
CLIENT = Together()

def build_prompt(title: str, context: str) -> str:
    """
    Builds an explained prompt for the LLM. 
    :param title: str = Title of the article
    :param context: str = Content of the article

    :return str = Explained user prompt for the LLM.
    """


    return f"""You are an AI assistant that generates training data for large language models.

Title: {title}
Article:
{context}

Task:
Based on the article above, generate a list of question and answer pairs in the following JSON format:
```json
{{
  "question": "...",
  "answer": "..."
}}
```
Enclose JSON between ```json and ``` code blocks.
"""

def generate_qa(title: str, content: str, model: str = "mistralai/Mixtral-8x7B-Instruct-v0.1") -> str:
    """
    Provided article title and content, uses an LLM to generate relevant question-answer pairs.
    :param title: str = Title of the article
    :param context: str = Content of the article
    :param model: str = Model ID of the Together LLM. Uses open source mixtral-8x7B model by default.

    :return str: Generated response from the completions endpoint.
    """


    prompt = build_prompt(title, content)
    
    response = CLIENT.chat.completions.create(
        messages=[
            {
                "role": "system", 
                "content": "You are a helpful assistant to generate structured synthetic question answering dataset for an LLM."
            },
            {
                "role": "user",
                "content": prompt
            }
        ],
        model=model,
    )

    return response.choices[0].message.content


def extract_json_from_markdown(text: str) -> List[Dict]:
    """
    Matches content between ```json and ``` blocks.
    Uses regex to parse the string content and convert the JSON.
    :param text: str = Generated content from the LLM.

    :return List[Dict] = A list of question-answer pairs generated by the LLM.
    """

    # -- Use regex to get all content between ```json and ``` -- #
    matches = re.findall(r"```json(.*?)```", text, re.DOTALL)
    json_objects = []

    for match in matches:
        try:
            obj = json.loads(match.strip())
            json_objects.append(obj)
        except json.JSONDecodeError as e:
            print("Error decoding JSON:", e)

    return json_objects

def main():
    FILE_PATH = "data/scraped_articles.json"    # File path of the scraped articles json. Fetched throgh scrape.py.
    assert os.path.exists(FILE_PATH), "No scrpaed data file found."
    
    with open(FILE_PATH) as f:
        articles = json.load(f)
        articles = list(filter(lambda x: "text" in x, articles))    # Only retain artciles that were successfully scraped.
    
    qa_pairs = []
    for article in tqdm(articles, desc="Generating Q/A Pairs"):
        try:
            qa_json = generate_qa(article["title"], article["text"])
            qa_json = extract_json_from_markdown(qa_json)
            qa_pairs.append({
                "url": article["url"],
                "generated_questions": qa_json
            })
        except Exception as e:
            print(f"Error processing article: {article['url']}\n{e}")

    with open("data/qa_dataset.json", "w") as f:
        json.dump(qa_pairs, f, indent=2)

if __name__ == "__main__":
    main()

